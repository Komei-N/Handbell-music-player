<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Handbell MusicXML Player (single file)</title>
<style>
  body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#fff; color:#000; }
  .app { max-width:1200px; margin:12px auto; padding:12px; }
  header { display:flex; align-items:center; gap:12px; }
  h1 { margin:0; font-size:18px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; }
  .left { width:360px; }
  .panel { padding:12px; border:1px solid #ccc; border-radius:6px; margin-top:12px; background:#fafafa; }
  .scoreContainer { position:relative; overflow:hidden; border:1px solid #ccc; border-radius:6px; height:440px; }
  #osmdCanvas { overflow-x:auto; white-space:nowrap; height:100%; }
  .cursorLine { position:absolute; top:0; width:3px; background:#d33; z-index:50; display:none; pointer-events:none; }
  label { display:block; margin-bottom:6px; font-size:13px; }
  input[type=range] { width:100%; }
  .partList label, .pitchList label { display:block; margin-bottom:4px; cursor:pointer; }
  .controls button { margin-right:6px; padding:6px 8px; }
  .progress { height:8px; background:#eee; border-radius:4px; overflow:hidden; margin-top:8px; }
  .bar { height:100%; width:0%; background:linear-gradient(90deg,#ff7a7a,#ffd7d7); }
  #log { height:120px; overflow:auto; background:#fff; border:1px solid #eee; padding:8px; font-size:12px; }
  .small { font-size:12px; color:#444; }
  /* make score inner svg stretch horizontally */
  #osmdCanvas > svg { display:inline-block; height:100%; }
</style>
</head>
<body>
<div class="app">
  <header><h1>Handbell MusicXML Player</h1></header>

  <div class="row">
    <div class="left panel">
      <div>
        <label>曲の選択</label>
        <select id="songSelect"></select>
        <button id="reloadBtn" style="margin-top:8px;">再読み込み</button>
      </div>

      <div style="margin-top:12px">
        <label>演奏するパート（最大3）</label>
        <div id="parts" class="partList"></div>
      </div>

      <div style="margin-top:12px">
        <label>演奏する音程（フィルタ、表示はそのまま）</label>
        <div id="pitches" class="pitchList"></div>
      </div>

      <div style="margin-top:12px">
        <label>テンポ（倍率 %）</label>
        <input type="range" id="tempoPercent" min="20" max="300" value="100">
        <div class="small">現在: <span id="tempoLabel">100%</span></div>
      </div>

      <div style="margin-top:12px">
        <label>音量 (dB)</label>
        <input type="range" id="volume" min="-24" max="6" value="-6">
      </div>

      <div class="controls" style="margin-top:12px">
        <button id="playBtn">再生</button>
        <button id="pauseBtn">一時停止</button>
        <button id="stopBtn">停止</button>
      </div>

      <div class="progress"><div class="bar" id="progressBar"></div></div>
      <div style="display:flex; justify-content:space-between; margin-top:6px;">
        <div class="small"><span id="timeLabel">0:00</span></div>
        <div class="small"><span id="durationLabel">0:00</span></div>
      </div>

      <div style="margin-top:10px">
        <div class="small">ログ / デバッグ：</div>
        <pre id="log"></pre>
      </div>
    </div>

    <div style="flex:1">
      <div class="panel scoreContainer">
        <div id="osmdCanvas"></div>
        <div class="cursorLine" id="cursorLine"></div>
      </div>
    </div>
  </div>
</div>

<!-- Libraries -->
<script src="https://unpkg.com/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
<script src="https://unpkg.com/tone/build/Tone.js"></script>
<script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>

<script>
// ================= Configuration =================
const builtIn = {
  "Song 1":"music/song1.musicxml",
  "Song 2":"music/song2.musicxml",
  "Song 3":"music/song3.musicxml"
};

// ================ DOM refs ======================
const songSelect = document.getElementById('songSelect');
const reloadBtn = document.getElementById('reloadBtn');
const partsContainer = document.getElementById('parts');
const pitchesContainer = document.getElementById('pitches');
const tempoPercent = document.getElementById('tempoPercent');
const tempoLabel = document.getElementById('tempoLabel');
const volumeSlider = document.getElementById('volume');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const progressBar = document.getElementById('progressBar');
const timeLabel = document.getElementById('timeLabel');
const durationLabel = document.getElementById('durationLabel');
const cursorLine = document.getElementById('cursorLine');
const osmdCanvas = document.getElementById('osmdCanvas');
const logEl = document.getElementById('log');

// ================ Player state =================
let osmd = null;
let synth = null;
let volumeNode = null;
let parsedEvents = [];    // {time, duration, midi, pitchName, partIndex}
let totalDuration = 0;    // seconds (original)
let partNames = [];
let pitchNames = [];
let toneParts = [];       // array of Tone.Part
let cursorTickerId = null;

// ================ Initialization ================
(function init(){
  // populate song select
  for(const k of Object.keys(builtIn)){
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k;
    songSelect.appendChild(opt);
  }
  songSelect.value = Object.keys(builtIn)[0];

  // events
  songSelect.addEventListener('change', ()=> loadSong(songSelect.value));
  reloadBtn.addEventListener('click', ()=> loadSong(songSelect.value));
  tempoPercent.addEventListener('input', onTempoInput);
  volumeSlider.addEventListener('input', onVolumeInput);
  playBtn.addEventListener('click', playMusic);
  pauseBtn.addEventListener('click', pauseMusic);
  stopBtn.addEventListener('click', stopMusic);

  // synth + volume
  synth = new Tone.FMSynth({
    harmonicity: 8,
    modulationIndex: 20,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 1.5, sustain: 0.0, release: 1.8 },
    modulation: { type: 'sine' },
    modulationEnvelope: { attack:0.001, decay:0.6, sustain:0.0, release:0.6 }
  });
  volumeNode = new Tone.Volume(parseInt(volumeSlider.value)).toDestination();
  synth.connect(volumeNode);

  // initial load
  loadSong(songSelect.value);
})();

// ================ Helpers & Logging ================
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function formatTime(s){
  if(!isFinite(s) || s <= 0) return '0:00';
  const m = Math.floor(s/60);
  const sec = Math.floor(s%60);
  return `${m}:${sec < 10 ? '0' : ''}${sec}`;
}

// ================ Load & Parse Score ================
async function loadSong(name){
  const url = builtIn[name];
  log(`曲読み込み: ${name} -> ${url}`);

  // fetch XML text for parsing
  let xmlText = '';
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    xmlText = await r.text();
  }catch(e){
    log(`ファイル読み込みエラー: ${e.message}`);
    alert('曲ファイルを読み込めませんでした。music/ 以下にファイルがあるか確認してください。');
    return;
  }

  // init OSMD if needed
  if(!osmd){
    osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdCanvas, {
      drawingParameters: 'compact',
      autoResize: true,
      pageFormat: { width: 2000, height: 400 }
    });
  }

  // load into OSMD. Prefer URL; fallback to xmlText if necessary.
  try{
    // many OSMD builds accept URL and will fetch internally; use url first.
    await osmd.load(url);
    await osmd.render();
    log('OSMD: 描画完了 (URL)');
  }catch(e){
    log('OSMD load(url)失敗、xmlTextでload試行: ' + e.message);
    try{
      await osmd.load(xmlText);
      await osmd.render();
      log('OSMD: 描画完了 (xmlText フォールバック)');
    }catch(e2){
      console.error(e2);
      alert('楽譜の描画に失敗しました（コンソールを確認してください）。');
      log('OSMD描画フォールバック失敗: ' + e2.message);
      return;
    }
  }

  // parse to extract note events and part/pitch lists
  const parsed = parseMusicXML(xmlText);
  parsedEvents = parsed.events;
  totalDuration = parsed.duration;
  partNames = parsed.parts.length ? parsed.parts.slice(0,3) : ['Part 1','Part 2','Part 3'];
  pitchNames = parsed.pitchNames && parsed.pitchNames.length ? parsed.pitchNames.slice() : Array.from(new Set(parsedEvents.map(e=>e.pitchName))).sort();

  if(pitchNames.length === 0){
    // fallback: build a few common pitches to avoid empty UI
    pitchNames = ['C4','D4','E4','F4','G4','A4','B4'];
  }

  // render UI
  renderPartUI();
  renderPitchUI();

  durationLabel.textContent = formatTime(totalDuration);
  progressBar.style.width = '0%';
  cursorLine.style.height = osmdCanvas.clientHeight + 'px';
  cursorLine.style.display = 'none';

  log(`解析完了: events=${parsedEvents.length}, duration=${totalDuration.toFixed(2)}s, parts=${partNames.join(',')}`);
}

// Very simple MusicXML parser to extract events, part names and pitch names
function parseMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, 'application/xml');
  const partNodes = Array.from(xml.querySelectorAll('part'));
  const partList = Array.from(xml.querySelectorAll('score-part')).map(p=>{
    const n = p.querySelector('part-name'); return n ? n.textContent.trim() : p.getAttribute('id') || 'Part';
  });

  let events = [];
  const pitchSet = new Set();

  partNodes.forEach((partNode, partIndex) => {
    let divisions = 1;
    let currentTempo = 120;
    let timeSec = 0;
    const measures = Array.from(partNode.querySelectorAll('measure'));
    measures.forEach(measure => {
      const attr = measure.querySelector('attributes');
      if(attr){ const d = attr.querySelector('divisions'); if(d) divisions = parseFloat(d.textContent) || divisions; }
      const sound = measure.querySelector('direction > sound, sound');
      if(sound && sound.getAttribute('tempo')){ const t = parseFloat(sound.getAttribute('tempo')); if(!isNaN(t) && t>0) currentTempo = t; }
      const notes = Array.from(measure.querySelectorAll('note'));
      notes.forEach(note => {
        if(note.querySelector('rest')){
          const dur = parseFloat(note.querySelector('duration')?.textContent || '0');
          if(!isNaN(dur)) timeSec += (dur/divisions) * (60/currentTempo);
          return;
        }
        const step = note.querySelector('pitch > step')?.textContent || 'C';
        const octave = parseInt(note.querySelector('pitch > octave')?.textContent || '4');
        const alter = parseInt(note.querySelector('pitch > alter')?.textContent || '0');
        const dur = parseFloat(note.querySelector('duration')?.textContent || '1');
        const midi = pitchToMidi(step, octave, alter);
        const secs = (dur/divisions) * (60/currentTempo);
        const pname = step + octave;
        pitchSet.add(pname);
        events.push({ time: timeSec, duration: secs, midi, pitchName: pname, partIndex });
        timeSec += secs;
      });
    });
  });

  const duration = events.reduce((m,e) => Math.max(m, e.time + e.duration), 0);
  return { events, parts: partList, duration, pitchNames: Array.from(pitchSet).sort() };
}
function pitchToMidi(step, oct, alter){
  const map = { C:0,D:2,E:4,F:5,G:7,A:9,B:11 };
  return (oct + 1) * 12 + (map[step.toUpperCase()] || 0) + (alter || 0);
}

// ================ UI rendering ==================
function renderPartUI(){
  partsContainer.innerHTML = '';
  // Ensure at least 3 placeholders if missing
  if(!partNames || partNames.length === 0) partNames = ['Part 1','Part 2','Part 3'];
  partNames.forEach((pn, i) => {
    const lab = document.createElement('label');
    lab.innerHTML = `<input type="checkbox" checked data-index="${i}"> ${pn}`;
    partsContainer.appendChild(lab);
    lab.querySelector('input').addEventListener('change', () => updateFilters());
  });
}
function renderPitchUI(){
  pitchesContainer.innerHTML = '';
  if(!pitchNames || pitchNames.length === 0) pitchNames = ['C4','D4','E4'];
  pitchNames.forEach(p => {
    const lab = document.createElement('label');
    lab.innerHTML = `<input type="checkbox" checked data-pitch="${p}"> ${p}`;
    pitchesContainer.appendChild(lab);
    lab.querySelector('input').addEventListener('change', () => updateFilters());
  });
}

// ================ Filters & Rescheduling ==================
async function updateFilters(){
  // collect selected parts and pitches
  let selectedParts = Array.from(partsContainer.querySelectorAll('input'))
    .map(ch => ch.checked ? parseInt(ch.getAttribute('data-index')) : null).filter(x=>x!==null);
  let selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(ch => ch.checked ? ch.getAttribute('data-pitch') : null).filter(Boolean);

  // if none selected, auto-select all (prevents "no target")
  if(selectedParts.length === 0){
    Array.from(partsContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedParts = Array.from(partsContainer.querySelectorAll('input')).map(ch => parseInt(ch.getAttribute('data-index')));
    log('注意: パートが未選択だったため全選択に戻しました。');
  }
  if(selectedPitches.length === 0){
    Array.from(pitchesContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedPitches = Array.from(pitchesContainer.querySelectorAll('input')).map(ch => ch.getAttribute('data-pitch'));
    log('注意: ピッチが未選択だったため全選択に戻しました。');
  }

  // redraw OSMD to show only selected parts (drawOnlyParts option)
  try{
    osmd.setOptions({ drawOnlyParts: selectedParts.length ? selectedParts : [] });
    await osmd.render();
    log(`OSMD: 再描画（表示パート: ${selectedParts.join(',')})`);
  }catch(e){
    console.warn('OSMD render failed after filter:', e);
  }

  // reschedule tone parts preserving playhead
  const wasPlaying = Tone.Transport.state === 'started';
  const currentSec = Tone.Transport.seconds;

  // dispose previous parts
  for(const p of toneParts){ try{ p.dispose(); }catch(_){ } }
  toneParts = [];
  Tone.Transport.cancel();

  // schedule new tone parts
  scheduleToneParts();

  if(wasPlaying){
    Tone.Transport.start(undefined, currentSec);
  } else {
    Tone.Transport.stop();
    updateCursorOnce();
  }
}

// ================ Scheduling playback (Tone.Part per part) ==================
function scheduleToneParts(){
  Tone.Transport.cancel(); // clear previous callbacks
  // collect selections
  let selectedParts = Array.from(partsContainer.querySelectorAll('input'))
    .map(ch => ch.checked ? parseInt(ch.getAttribute('data-index')) : null).filter(x=>x!==null);
  let selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(ch => ch.checked ? ch.getAttribute('data-pitch') : null).filter(Boolean);

  // if empty, default to all (and ensure UI is checked)
  if(selectedParts.length === 0){
    Array.from(partsContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedParts = Array.from(partsContainer.querySelectorAll('input')).map(ch => parseInt(ch.getAttribute('data-index')));
  }
  if(selectedPitches.length === 0){
    Array.from(pitchesContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedPitches = Array.from(pitchesContainer.querySelectorAll('input')).map(ch => ch.getAttribute('data-pitch'));
  }

  const tempoScale = parseInt(tempoPercent.value) / 100;

  // Build events per part and create Tone.Part
  toneParts = [];
  for(const partIndex of selectedParts){
    const eventsForPart = parsedEvents
      .filter(e => e.partIndex === partIndex && selectedPitches.includes(e.pitchName))
      .map(e => ({ time: e.time / tempoScale, duration: e.duration / tempoScale, midi: e.midi }));

    if(eventsForPart.length === 0){
      log(`パート ${partIndex} に再生イベントがありません（選択フィルタ）`);
      continue;
    }

    const part = new Tone.Part((time, val) => {
      synth.triggerAttackRelease(Tone.Frequency(val.midi,'midi'), val.duration, time);
    }, eventsForPart);

    part.start(0);
    toneParts.push(part);
  }

  if(toneParts.length === 0){
    log('フィルタ適用後、再生対象がありません（パート/ピッチを確認してください）。');
    // update duration label to original (no scaling)
    durationLabel.textContent = formatTime(totalDuration);
    return;
  }

  // schedule cursor updater at ~30ms interval
  Tone.Transport.scheduleRepeat(updateCursorOnce, 0.03);

  // update duration label to scaled total
  const effTotal = totalDuration / (parseInt(tempoPercent.value)/100);
  durationLabel.textContent = formatTime(effTotal);
}

// ================ Playback controls ==================
async function playMusic(){
  await Tone.start();
  if(toneParts.length === 0){
    scheduleToneParts();
  }
  if(toneParts.length === 0){
    // nothing to play
    log('再生対象がありません（パート/ピッチ設定を確認してください）。');
    alert('再生対象がありません（パート/ピッチ設定を確認してください）。');
    return;
  }
  if(Tone.Transport.state !== 'started'){
    Tone.Transport.start();
  }
  cursorLine.style.display = 'block';
  log('再生開始');
}
function pauseMusic(){
  if(Tone.Transport.state === 'started'){
    Tone.Transport.pause();
    log('一時停止');
  }
}
function stopMusic(){
  if(Tone.Transport.state === 'started' || Tone.Transport.state === 'paused'){
    Tone.Transport.stop();
  }
  // dispose toneParts
  for(const p of toneParts){ try{ p.dispose(); }catch(_){ } }
  toneParts = [];
  Tone.Transport.cancel();
  progressBar.style.width = '0%';
  timeLabel.textContent = '0:00';
  cursorLine.style.display = 'none';
  log('停止');
}

// ================ Tempo / Volume handlers ==================
function onTempoInput(){
  tempoLabel.textContent = tempoPercent.value + '%';
  // if playing, reschedule from current time
  if(Tone.Transport.state === 'started'){
    const sec = Tone.Transport.seconds;
    rescheduleFrom(sec);
  } else {
    // just update duration label (display scaled)
    const effTotal = totalDuration / (parseInt(tempoPercent.value)/100);
    durationLabel.textContent = formatTime(effTotal);
  }
}

function onVolumeInput(){
  if(volumeNode) volumeNode.volume.value = parseInt(volumeSlider.value);
}

// ================ Cursor update & click-to-jump ==============
function updateCursorOnce(){
  const tempoScale = parseInt(tempoPercent.value)/100;
  const effTotal = totalDuration / tempoScale;
  const sec = Tone.Transport.seconds;
  const pct = effTotal > 0 ? Math.min(1, sec / effTotal) : 0;
  progressBar.style.width = (pct * 100) + '%';
  timeLabel.textContent = formatTime(sec);
  const width = osmdCanvas.scrollWidth || osmdCanvas.clientWidth || 1;
  const left = pct * width;
  cursorLine.style.left = left + 'px';
  cursorLine.style.display = 'block';
  const desired = Math.max(0, left - osmdCanvas.clientWidth/2);
  osmdCanvas.scrollLeft = desired;
  if(pct >= 1){
    stopMusic();
  }
}

// map click on osmdCanvas to time and start playback there
osmdCanvas.addEventListener('click', async (ev) => {
  const rect = osmdCanvas.getBoundingClientRect();
  const x = ev.clientX - rect.left + osmdCanvas.scrollLeft;
  const width = osmdCanvas.scrollWidth || osmdCanvas.clientWidth || 1;
  const pct = Math.max(0, Math.min(1, x / width));
  const tempoScale = parseInt(tempoPercent.value)/100;
  const effTotal = totalDuration / tempoScale;
  const targetSec = Math.max(0, Math.min(effTotal, pct * effTotal));

  // restart schedule and start at targetSec
  // stop existing
  if(Tone.Transport.state === 'started' || Tone.Transport.state === 'paused'){
    stopMusic();
  }
  scheduleToneParts();
  if(toneParts.length === 0){
    alert('クリック位置に再生対象がありません（パート/ピッチを確認してください）。');
    return;
  }
  await Tone.start();
  Tone.Transport.start(undefined, targetSec);
  log(`クリック再生: ${targetSec.toFixed(2)}s (${(pct*100).toFixed(1)}%)`);
  cursorLine.style.display = 'block';
});

// ================ Reschedule helper ==================
function rescheduleFrom(sec){
  try{ Tone.Transport.pause(); }catch(_){}
  for(const p of toneParts){ try{ p.dispose(); }catch(_){ } }
  toneParts = [];
  scheduleToneParts();
  Tone.Transport.start(undefined, sec);
  log('再スケジュール: 再開時刻=' + sec.toFixed(2) + 's');
}
</script>
</body>
</html>
