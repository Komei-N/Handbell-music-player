<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Handbell MusicXML Player (GitHub Pages)</title>
<style>
body { margin:0; font-family:Arial,sans-serif; background:#fff; color:#000; }
.app { max-width:1200px; margin:10px auto; padding:12px; }
header { display:flex; align-items:center; gap:12px; }
h1 { margin:0; font-size:18px; }
.row { display:flex; gap:12px; flex-wrap:wrap; }
.left { width:360px; }
.panel { padding:12px; border:1px solid #ccc; border-radius:6px; margin-top:12px; }
.scoreContainer { position:relative; overflow:hidden; border:1px solid #ccc; border-radius:6px; height:400px; }
#osmdCanvas { overflow-x:auto; white-space:nowrap; height:100%; }
.cursorLine { position:absolute; top:0; width:3px; background:red; z-index:10; display:none; }
label { display:block; margin-bottom:6px; font-size:13px; }
input[type=range] { width:100%; }
.partList label, .pitchList label { display:block; margin-bottom:4px; cursor:pointer; }
.controls button { margin-right:6px; }
.progress { height:8px; background:#eee; border-radius:4px; overflow:hidden; margin-top:6px; }
.bar { height:100%; width:0%; background:red; }
</style>
</head>
<body>
<div class="app">
  <header><h1>Handbell MusicXML Player</h1></header>
  <div class="row">
    <div class="left panel">
      <div>
        <label>曲の選択</label>
        <select id="songSelect"></select>
      </div>

      <div style="margin-top:12px">
        <label>演奏するパート</label>
        <div id="parts" class="partList"></div>
      </div>

      <div style="margin-top:12px">
        <label>演奏する音程</label>
        <div id="pitches" class="pitchList"></div>
      </div>

      <div style="margin-top:12px">
        <label>テンポ (%)</label>
        <input type="range" id="tempoPercent" min="20" max="300" value="100">
        <span id="tempoLabel">100%</span>
      </div>

      <div style="margin-top:12px">
        <label>音量 (dB)</label>
        <input type="range" id="volume" min="-24" max="6" value="-6">
      </div>

      <div class="controls" style="margin-top:12px">
        <button id="playBtn">再生</button>
        <button id="pauseBtn">一時停止</button>
        <button id="stopBtn">停止</button>
      </div>

      <div class="progress"><div class="bar" id="progressBar"></div></div>
      <div style="display:flex; justify-content:space-between; font-size:12px;">
        <span id="timeLabel">0:00</span>
        <span id="durationLabel">0:00</span>
      </div>
    </div>

    <div style="flex:1">
      <div class="panel scoreContainer">
        <div id="osmdCanvas"></div>
        <div class="cursorLine" id="cursorLine"></div>
      </div>
    </div>
  </div>
</div>

<!-- ライブラリ -->
<script src="https://unpkg.com/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
<script src="https://unpkg.com/tone/build/Tone.js"></script>
<script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>

<script>
// ========== 内蔵3曲（パスは /music/*.musicxml に置くこと） ==========
const builtIn = {
  "Song 1":"music/song1.musicxml",
  "Song 2":"music/song2.musicxml",
  "Song 3":"music/song3.musicxml"
};

// DOM
const songSelect = document.getElementById('songSelect');
const partsContainer = document.getElementById('parts');
const pitchesContainer = document.getElementById('pitches');
const tempoPercent = document.getElementById('tempoPercent');
const tempoLabel = document.getElementById('tempoLabel');
const volumeSlider = document.getElementById('volume');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const progressBar = document.getElementById('progressBar');
const timeLabel = document.getElementById('timeLabel');
const durationLabel = document.getElementById('durationLabel');
const cursorLine = document.getElementById('cursorLine');
const osmdCanvas = document.getElementById('osmdCanvas');

let osmd = null;
let synth = null;
let volumeNode = null;
let parsedEvents = []; // {time,duration,midi,pitchName,partIndex}
let totalDuration = 0;
let partNames = [];
let pitchNames = [];
let tonePart = null;
let transportStarted = false;

// ---------- 初期化 ----------
(async function init(){
  // 曲セレクトを作る
  const keys = Object.keys(builtIn);
  for(const k of keys){
    const opt = document.createElement('option'); opt.value=k; opt.textContent=k; songSelect.appendChild(opt);
  }
  songSelect.value = keys[0];

  // イベント
  songSelect.addEventListener('change', ()=>loadSong(songSelect.value));
  tempoPercent.addEventListener('input', ()=>{
    tempoLabel.textContent = tempoPercent.value + '%';
    // tempo変更時は再スケジュール（再生中は続行）
    if(tonePart){
      const currentSec = Tone.Transport.seconds;
      tonePart.dispose(); tonePart = null;
      scheduleTonePart(); // will start at 0
      // resume at same logical time
      Tone.Transport.start(undefined, currentSec);
    }
  });
  volumeSlider.addEventListener('input', ()=>{ if(volumeNode) volumeNode.volume.value = parseInt(volumeSlider.value); });
  playBtn.addEventListener('click', playMusic);
  pauseBtn.addEventListener('click', pauseMusic);
  stopBtn.addEventListener('click', stopMusic);

  // synth + volume
  synth = new Tone.FMSynth({
    harmonicity: 8, modulationIndex:20,
    oscillator:{type:'sine'},
    envelope:{attack:0.001, decay:1.5, sustain:0, release:1.8},
    modulation:{type:'sine'},
    modulationEnvelope:{attack:0.001, decay:0.6, sustain:0, release:0.6}
  });
  volumeNode = new Tone.Volume(parseInt(volumeSlider.value)).toDestination();
  synth.connect(volumeNode);

  // 最初の曲ロード
  await loadSong(songSelect.value);
})();

// ---------- 曲ロード（最小変更で安定化） ----------
async function loadSong(name){
  const url = builtIn[name];
  // fetch XML text for parsing (we still need text to build parsedEvents),
  // but pass URL to osmd.load() (OSMD expects URL or raw XML with different API).
  const resp = await fetch(url);
  if(!resp.ok){ alert(`曲ファイルを読み込めません: ${url} (HTTP ${resp.status})`); return; }
  const xmlText = await resp.text();

  // OSMD 初期化（1段を横に連続表示する方向で最小限のオプション）
  if(!osmd){
    osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdCanvas, {
      drawingParameters: 'compact',
      // 横長描画をしやすくするためページ幅を大きめに設定
      pageFormat: { width: 2000, height: 400 },
      // ※ OSMD のバージョンやオプションにより挙動が変わるため、
      //    必要ならここを微調整してください。
    });
  }

  // setOptions で初期的にすべてのパートを描く（フィルタ時に再描画する）
  osmd.setOptions({ drawOnlyParts: [] });

  // load は URL を渡す（文字列 XML を渡すと内部で想定外になる場合があるため URL を使用）
  // ここでURLを渡すと自動で fetch してくれる実装のOSMDもあるため安全
  try{
    await osmd.load(url); // <-- ここを「xmlText」から「url」に変更（重要）
    await osmd.render();
  }catch(e){
    console.error('OSMD load/render error:', e);
    alert('楽譜表示に失敗しました。コンソールを確認してください。');
    return;
  }

  // 解析は自前で行う（parsedEvents を作る）
  const parsed = parseMusicXML(xmlText);
  parsedEvents = parsed.events;
  totalDuration = parsed.duration;
  partNames = parsed.parts.slice(0,3); // 最大3パート
  pitchNames = Array.from(new Set(parsed.events.map(e=>e.pitchName))).sort();

  renderPartUI();
  renderPitchUI();

  durationLabel.textContent = formatTime(totalDuration);
  cursorLine.style.height = osmdCanvas.clientHeight + 'px';
  // reset progress
  progressBar.style.width = '0%';
}

// ---------- MusicXML 解析（最小限） ----------
function parseMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText,'application/xml');
  const partNodes = Array.from(xml.querySelectorAll('part'));
  const partList = Array.from(xml.querySelectorAll('score-part')).map(p=>p.querySelector('part-name')?.textContent || p.getAttribute('id') || 'Part');
  let events = [];
  partNodes.forEach((partNode, pi) => {
    let divisions = 1, tempo = 120, timeSec = 0;
    const measures = Array.from(partNode.querySelectorAll('measure'));
    measures.forEach(measure => {
      const attr = measure.querySelector('attributes');
      if(attr){ const d = attr.querySelector('divisions'); if(d) divisions = parseFloat(d.textContent); }
      const sound = measure.querySelector('direction > sound, sound');
      if(sound && sound.getAttribute('tempo')) tempo = parseFloat(sound.getAttribute('tempo'));
      const notes = Array.from(measure.querySelectorAll('note'));
      notes.forEach(note => {
        if(note.querySelector('rest')){
          const dur = parseFloat(note.querySelector('duration')?.textContent || 0);
          timeSec += dur / divisions * (60/tempo);
          return;
        }
        const step = note.querySelector('pitch > step')?.textContent || 'C';
        const octave = parseInt(note.querySelector('pitch > octave')?.textContent || '4');
        const alter = parseInt(note.querySelector('pitch > alter')?.textContent || '0');
        const dur = parseFloat(note.querySelector('duration')?.textContent || '1');
        const midi = pitchToMidi(step, octave, alter);
        const secs = dur / divisions * (60/tempo);
        events.push({ time: timeSec, duration: secs, midi, pitchName: step + octave, partIndex: pi });
        timeSec += secs;
      });
    });
  });
  const duration = events.reduce((m,e)=>Math.max(m, e.time + e.duration), 0);
  return { events, parts: partList, duration };
}
function pitchToMidi(step, oct, alter){ const map={C:0,D:2,E:4,F:5,G:7,A:9,B:11}; return (oct+1)*12 + (map[step.toUpperCase()]||0) + (alter||0); }

// ---------- UI（パート・ピッチ表示） ----------
function renderPartUI(){
  partsContainer.innerHTML = '';
  partNames.forEach((p, i) => {
    const lab = document.createElement('label');
    lab.innerHTML = `<input type="checkbox" checked data-index="${i}"> ${p}`;
    partsContainer.appendChild(lab);
    lab.querySelector('input').addEventListener('change', async ()=>{ await updateFilters(); });
  });
}
function renderPitchUI(){
  pitchesContainer.innerHTML = '';
  pitchNames.forEach(p => {
    const lab = document.createElement('label');
    lab.innerHTML = `<input type="checkbox" checked data-pitch="${p}"> ${p}`;
    pitchesContainer.appendChild(lab);
    lab.querySelector('input').addEventListener('change', async ()=>{ await updateFilters(); });
  });
}

// ---------- フィルタ更新（表示と再生データの反映） ----------
async function updateFilters(){
  // どのパートを表示するか
  const selectedPartIndices = Array.from(partsContainer.querySelectorAll('input'))
    .map(i => i.checked ? parseInt(i.getAttribute('data-index')) : null)
    .filter(i => i !== null);

  // which pitches are allowed (for playback)
  const selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(i => i.checked ? i.getAttribute('data-pitch') : null)
    .filter(Boolean);

  // OSMD の描画を再設定（drawOnlyParts による再描画）
  // drawOnlyParts: [] -> 全部表示, otherwise array of indices
  try{
    osmd.setOptions({ drawOnlyParts: selectedPartIndices.length ? selectedPartIndices : [] });
    await osmd.render(); // re-render with new part selection
  }catch(e){
    console.warn('OSMD render after filter failed:', e);
  }

  // 再生中の場合は tonePart を再生成して継続（位置を維持）
  const currentlyPlaying = Tone.Transport.state === 'started' && tonePart;
  const currentSec = Tone.Transport.seconds;
  if(tonePart){
    tonePart.dispose(); tonePart = null;
  }
  // scheduleTonePart will create a new tonePart according to selectedParts/pitches
  scheduleTonePart();
  if(currentlyPlaying){
    // resume Transport at same logical time
    Tone.Transport.start(undefined, currentSec);
  } else {
    Tone.Transport.stop();
  }
}

// ---------- 再生制御（安定化） ----------
async function playMusic(){
  await Tone.start(); // 必ずユーザー操作から呼ばれるので許可が得られる
  // if already scheduled, just start transport; otherwise schedule then start
  if(!tonePart){
    scheduleTonePart();
  }
  Tone.Transport.start();
  transportStarted = true;
}
function pauseMusic(){
  if(Tone.Transport.state === 'started'){
    Tone.Transport.pause();
  }
}
function stopMusic(){
  if(tonePart){ tonePart.dispose(); tonePart = null; }
  Tone.Transport.stop();
  progressBar.style.width = '0%';
  timeLabel.textContent = '0:00';
  // reset transport schedule callbacks
  Tone.Transport.cancel();
}

// ---------- Tone.Part スケジュール（選択フィルタを反映） ----------
function scheduleTonePart(){
  // dispose existing
  if(tonePart){ tonePart.dispose(); tonePart = null; }
  // collect selected parts and pitches
  const selectedParts = Array.from(partsContainer.querySelectorAll('input'))
    .map(i => i.checked ? parseInt(i.getAttribute('data-index')) : null).filter(i => i !== null);
  const selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(i => i.checked ? i.getAttribute('data-pitch') : null).filter(Boolean);
  const tempoScale = parseInt(tempoPercent.value) / 100;

  // filter events for playback
  const playEvents = parsedEvents.filter(e => selectedParts.includes(e.partIndex) && selectedPitches.includes(e.pitchName))
    .map(e => ({ time: e.time / tempoScale, duration: e.duration / tempoScale, midi: e.midi }));

  if(playEvents.length === 0){
    // nothing to play, ensure transport has no schedules
    Tone.Transport.cancel();
    totalDuration = 0;
    return;
  }

  // create Tone.Part with stable scheduling (reduces glitching)
  tonePart = new Tone.Part((time, value) => {
    synth.triggerAttackRelease(Tone.Frequency(value.midi, 'midi'), value.duration, time);
  }, playEvents);

  tonePart.start(0);

  // Cancel old update and set new repeating cursor updater
  Tone.Transport.cancel(); // cancel previous schedules (but not part)
  Tone.Transport.scheduleRepeat(updateCursor, 0.05);
}

// ---------- カーソル更新 & 自動スクロール ----------
function updateCursor(){
  // Transport.seconds corresponds to scaled time (we scheduled events with /tempoScale)
  const sec = Tone.Transport.seconds;
  // compute effective total (scaled)
  const tempoScale = parseInt(tempoPercent.value) / 100;
  const effectiveTotal = totalDuration / tempoScale;
  const pct = effectiveTotal > 0 ? Math.min(1, sec / effectiveTotal) : 0;
  progressBar.style.width = (pct * 100) + '%';
  timeLabel.textContent = formatTime(sec);

  // position cursor relative to osmdCanvas width
  const width = osmdCanvas.scrollWidth || osmdCanvas.clientWidth || 1;
  cursorLine.style.display = 'block';
  const leftPx = pct * width;
  cursorLine.style.left = leftPx + 'px';

  // auto-scroll so cursor is centered (clamp)
  const desiredScroll = Math.max(0, leftPx - osmdCanvas.clientWidth / 2);
  osmdCanvas.scrollLeft = desiredScroll;

  // stop when done
  if(pct >= 1){
    // stop completely
    stopMusic();
  }
}

// ---------- ユーティリティ ----------
function formatTime(s){
  if(!isFinite(s) || s <= 0) return '0:00';
  const m = Math.floor(s/60);
  const sec = Math.floor(s % 60);
  return `${m}:${sec < 10 ? '0' : ''}${sec}`;
}
</script>
</body>
</html>
