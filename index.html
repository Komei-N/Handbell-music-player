<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Handbell Player Base</title>
<style>
body {margin:0;font-family:sans-serif;}
.app {max-width:1200px;margin:0 auto;padding:12px;}
header {margin-bottom:12px;}
#score {border:1px solid #ccc;height:400px;overflow:auto;position:relative;}
#cursor {position:absolute;top:0;width:3px;background:red;height:100%;display:none;}
</style>
</head>
<body>
<div class="app">
  <header><h1>Handbell Player Base</h1></header>
  <div>
    <label>曲の選択：
      <select id="song">
        <option value="music/song1.musicxml">Song1</option>
        <option value="music/song2.musicxml">Song2</option>
        <option value="music/song3.musicxml">Song3</option>
      </select>
    </label>
    <button id="load">読み込む</button>
    <button id="play">再生</button>
    <button id="stop">停止</button>
  </div>
  <div id="score">
    <div id="cursor"></div>
  </div>
</div>
<script src="https://unpkg.com/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
<script src="https://unpkg.com/tone/build/Tone.js"></script>
<script>
const osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("score",{drawingParameters:"compact"});
let events=[]; let total=0;
const synth = new Tone.FMSynth({
  harmonicity:8,modulationIndex:20,oscillator:{type:'sine'},
  envelope:{attack:0.001,decay:1.5,sustain:0,release:1.8},
  modulation:{type:'sine'},
  modulationEnvelope:{attack:0.001,decay:0.6,sustain:0,release:0.6}
}).toDestination();

document.getElementById("load").onclick=async()=>{
  const url=document.getElementById("song").value;
  const xml=await fetch(url).then(r=>r.text());
  await osmd.load(xml);
  await osmd.render();
  //簡易的に全音符スケジュールを作る
  events=parseXML(xml);
  total=events.reduce((m,e)=>Math.max(m,e.time+e.duration),0);
};

document.getElementById("play").onclick=()=>{
  if(events.length===0) return;
  Tone.Transport.cancel(); //前回クリア
  events.forEach(e=>{
    Tone.Transport.schedule(time=>{
      synth.triggerAttackRelease(Tone.Frequency(e.midi,"midi"),e.duration,time);
    },e.time);
  });
  Tone.Transport.start();
};

document.getElementById("stop").onclick=()=>{
  Tone.Transport.stop();
};

function parseXML(xmlText){
  const parser=new DOMParser();
  const xml=parser.parseFromString(xmlText,"application/xml");
  const partNodes=Array.from(xml.querySelectorAll("part"));
  let ev=[];
  partNodes.forEach((p,pi)=>{
    let divisions=1,tempo=120,timeSec=0;
    const measures=Array.from(p.querySelectorAll("measure"));
    measures.forEach(m=>{
      const attr=m.querySelector("attributes");
      if(attr){const d=attr.querySelector("divisions");if(d)divisions=parseFloat(d.textContent);}
      const sound=m.querySelector("direction>sound,sound");
      if(sound && sound.getAttribute("tempo")) tempo=parseFloat(sound.getAttribute("tempo"));
      const notes=Array.from(m.querySelectorAll("note"));
      notes.forEach(n=>{
        if(n.querySelector("rest")){
          const dur=parseFloat(n.querySelector("duration")?.textContent||0);
          timeSec+=dur/divisions*(60/tempo);
          return;
        }
        const step=n.querySelector("pitch>step")?.textContent;
        const octave=n.querySelector("pitch>octave")?.textContent;
        const alter=n.querySelector("pitch>alter")?.textContent||0;
        const dur=parseFloat(n.querySelector("duration")?.textContent||0);
        const midi=pitchToMidi(step,parseInt(octave),parseInt(alter));
        const secs=dur/divisions*(60/tempo);
        ev.push({time:timeSec,duration:secs,midi});
        timeSec+=secs;
      });
    });
  });
  return ev;
}
function pitchToMidi(step,oct,alter){
  const map={C:0,D:2,E:4,F:5,G:7,A:9,B:11};
  return (oct+1)*12+(map[step.toUpperCase()]||0)+alter;
}
</script>
</body>
</html>
