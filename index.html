<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Handbell MusicXML Player (single file)</title>
<style>
  body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#fff; color:#000; }
  .app { max-width:1200px; margin:12px auto; padding:12px; }
  header { display:flex; align-items:center; gap:12px; }
  h1 { margin:0; font-size:18px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; }
  .left { width:360px; }
  .panel { padding:12px; border:1px solid #ccc; border-radius:6px; margin-top:12px; background:#fafafa; }
  .scoreContainer { position:relative; overflow:hidden; border:1px solid #ccc; border-radius:6px; height:440px; }
  #osmdCanvas { overflow-x:auto; white-space:nowrap; height:100%; }
  .cursorLine { position:absolute; top:0; width:3px; background:#d33; z-index:50; display:none; }
  label { display:block; margin-bottom:6px; font-size:13px; }
  input[type=range] { width:100%; }
  .partList label, .pitchList label { display:block; margin-bottom:4px; cursor:pointer; }
  .controls button { margin-right:6px; padding:6px 8px; }
  .progress { height:8px; background:#eee; border-radius:4px; overflow:hidden; margin-top:8px; }
  .bar { height:100%; width:0%; background:linear-gradient(90deg,#ff7a7a,#ffd7d7); }
  #log { height:120px; overflow:auto; background:#fff; border:1px solid #eee; padding:8px; font-size:12px; }
  .small { font-size:12px; color:#444; }
</style>
</head>
<body>
<div class="app">
  <header><h1>Handbell MusicXML Player</h1></header>

  <div class="row">
    <div class="left panel">
      <div>
        <label>曲の選択</label>
        <select id="songSelect"></select>
        <button id="reloadBtn" style="margin-top:8px;">再読み込み</button>
      </div>

      <div style="margin-top:12px">
        <label>演奏するパート（最大3）</label>
        <div id="parts" class="partList"></div>
      </div>

      <div style="margin-top:12px">
        <label>演奏する音程（フィルタ、表示はそのまま）</label>
        <div id="pitches" class="pitchList"></div>
      </div>

      <div style="margin-top:12px">
        <label>テンポ（倍率 %）</label>
        <input type="range" id="tempoPercent" min="20" max="300" value="100">
        <div class="small">現在: <span id="tempoLabel">100%</span></div>
      </div>

      <div style="margin-top:12px">
        <label>音量 (dB)</label>
        <input type="range" id="volume" min="-24" max="6" value="-6">
      </div>

      <div class="controls" style="margin-top:12px">
        <button id="playBtn">再生</button>
        <button id="pauseBtn">一時停止</button>
        <button id="stopBtn">停止</button>
      </div>

      <div class="progress"><div class="bar" id="progressBar"></div></div>
      <div style="display:flex; justify-content:space-between; margin-top:6px;">
        <div class="small"><span id="timeLabel">0:00</span></div>
        <div class="small"><span id="durationLabel">0:00</span></div>
      </div>

      <div style="margin-top:10px">
        <div class="small">ログ / デバッグ：</div>
        <pre id="log"></pre>
      </div>
    </div>

    <div style="flex:1">
      <div class="panel scoreContainer">
        <div id="osmdCanvas"></div>
        <div class="cursorLine" id="cursorLine"></div>
      </div>
    </div>
  </div>
</div>

<!-- ライブラリ -->
<script src="https://unpkg.com/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
<script src="https://unpkg.com/tone/build/Tone.js"></script>
<script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>

<script>
/* ============================
   Configuration: 3 built-in songs
   Place your files at:
     /music/song1.musicxml
     /music/song2.musicxml
     /music/song3.musicxml
   ============================ */
const builtIn = {
  "Song 1":"music/song1.musicxml",
  "Song 2":"music/song2.musicxml",
  "Song 3":"music/song3.musicxml"
};

/* ====== DOM elements ====== */
const songSelect = document.getElementById('songSelect');
const reloadBtn = document.getElementById('reloadBtn');
const partsContainer = document.getElementById('parts');
const pitchesContainer = document.getElementById('pitches');
const tempoPercent = document.getElementById('tempoPercent');
const tempoLabel = document.getElementById('tempoLabel');
const volumeSlider = document.getElementById('volume');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const progressBar = document.getElementById('progressBar');
const timeLabel = document.getElementById('timeLabel');
const durationLabel = document.getElementById('durationLabel');
const cursorLine = document.getElementById('cursorLine');
const osmdCanvas = document.getElementById('osmdCanvas');
const logEl = document.getElementById('log');

/* ====== Player state ====== */
let osmd = null;
let synth = null;         // single synth used by all parts
let volumeNode = null;
let parsedEvents = [];    // {time, duration, midi, pitchName, partIndex}
let totalDuration = 0;    // seconds (original score tempo)
let partNames = [];
let pitchNames = [];
let toneParts = [];       // Tone.Part per partIndex (max 3)

/* ====== Initialize UI and libraries ====== */
(function init(){
  // populate song select
  for(const k of Object.keys(builtIn)){
    const opt = document.createElement('option'); opt.value = k; opt.textContent = k; songSelect.appendChild(opt);
  }
  songSelect.value = Object.keys(builtIn)[0];

  // events
  songSelect.addEventListener('change', ()=> loadSong(songSelect.value));
  reloadBtn.addEventListener('click', ()=> loadSong(songSelect.value));
  tempoPercent.addEventListener('input', ()=>{
    tempoLabel.textContent = tempoPercent.value + '%';
    if(Tone.Transport.state === 'started'){
      const sec = Tone.Transport.seconds;
      rescheduleFrom(sec);
    }
  });
  volumeSlider.addEventListener('input', ()=> {
    if(volumeNode) volumeNode.volume.value = parseInt(volumeSlider.value);
  });

  playBtn.addEventListener('click', playMusic);
  pauseBtn.addEventListener('click', pauseMusic);
  stopBtn.addEventListener('click', stopMusic);

  // create synth + volume
  synth = new Tone.FMSynth({
    harmonicity: 8,
    modulationIndex: 20,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 1.5, sustain: 0.0, release: 1.8 },
    modulation: { type: 'sine' },
    modulationEnvelope: { attack:0.001, decay:0.6, sustain:0.0, release:0.6 }
  });
  volumeNode = new Tone.Volume(parseInt(volumeSlider.value)).toDestination();
  synth.connect(volumeNode);

  // load first song
  loadSong(songSelect.value);
})();

/* ====== Utility logging ====== */
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

/* ====== Load and render score ====== */
async function loadSong(name){
  const url = builtIn[name];
  log(`曲読み込み: ${name} -> ${url}`);
  // fetch xml text for parsing
  let xmlText;
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    xmlText = await r.text();
  }catch(e){
    log(`ファイル読み込みエラー: ${e.message}`);
    alert(`曲ファイル ${url} を読み込めませんでした。ブラウザコンソールを確認してください。`);
    return;
  }

  // initialize OSMD if needed
  if(!osmd){
    osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdCanvas, {
      drawingParameters: 'compact',
      autoResize: true,
      pageFormat: { width: 2000, height: 400 }
    });
  }

  // Try to load by URL first (preferred), else fallback to xmlText
  try{
    await osmd.load(url);
    await osmd.render();
    log('OSMD: 描画完了 (URL)');
  }catch(e){
    log('OSMD load(url)失敗、xmlTextでload試行: ' + e.message);
    try{
      await osmd.load(xmlText);
      await osmd.render();
      log('OSMD: 描画完了 (xmlText フォールバック)');
    }catch(e2){
      console.error(e2);
      alert('楽譜の描画に失敗しました（詳細はコンソール）。');
      log('OSMD描画フォールバック失敗: ' + e2.message);
      return;
    }
  }

  // Parse MusicXML to extract note timings and parts (we need times for playback)
  const parsed = parseMusicXML(xmlText);
  parsedEvents = parsed.events;         // full array of events across parts
  totalDuration = parsed.duration;
  partNames = parsed.parts.slice(0,3);  // max 3 parts
  pitchNames = Array.from(new Set(parsedEvents.map(e=>e.pitchName))).sort();

  // populate UI for parts / pitches
  renderPartUI();
  renderPitchUI();

  durationLabel.textContent = formatTime(totalDuration);

  // position cursor initial
  cursorLine.style.height = osmdCanvas.clientHeight + 'px';
  cursorLine.style.display = 'none';
  progressBar.style.width = '0%';

  log(`解析完了: events=${parsedEvents.length}, duration=${totalDuration.toFixed(2)}s, parts=${partNames.join(',')}`);
}

/* ====== MusicXML parser (simple, supports tempo change via <direction><sound tempo=".."/>) ====== */
function parseMusicXML(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText,'application/xml');
  const partNodes = Array.from(xml.querySelectorAll('part'));
  const partList = Array.from(xml.querySelectorAll('score-part')).map(p => {
    const nameNode = p.querySelector('part-name');
    return nameNode ? nameNode.textContent.trim() : p.getAttribute('id') || 'Part';
  });

  let events = [];
  partNodes.forEach((partNode, partIndex) => {
    let divisions = 1;
    let currentTempo = 120; // default
    let timeSec = 0;
    const measures = Array.from(partNode.querySelectorAll('measure'));
    measures.forEach(measure => {
      const attr = measure.querySelector('attributes');
      if(attr){
        const d = attr.querySelector('divisions');
        if(d) divisions = parseFloat(d.textContent) || divisions;
      }
      // tempo change
      const sound = measure.querySelector('direction > sound, sound');
      if(sound && sound.getAttribute('tempo')){
        const t = parseFloat(sound.getAttribute('tempo'));
        if(!isNaN(t) && t > 0) currentTempo = t;
      }
      // notes
      const notes = Array.from(measure.querySelectorAll('note'));
      notes.forEach(note => {
        if(note.querySelector('rest')){
          const dur = parseFloat(note.querySelector('duration')?.textContent || '0');
          if(!isNaN(dur)) timeSec += (dur / divisions) * (60 / currentTempo);
          return;
        }
        const step = note.querySelector('pitch > step')?.textContent || 'C';
        const octave = parseInt(note.querySelector('pitch > octave')?.textContent || '4');
        const alter = parseInt(note.querySelector('pitch > alter')?.textContent || '0');
        const dur = parseFloat(note.querySelector('duration')?.textContent || '1');
        const midi = pitchToMidi(step, octave, alter);
        const secs = (dur / divisions) * (60 / currentTempo);
        events.push({ time: timeSec, duration: secs, midi, pitchName: step + octave, partIndex });
        timeSec += secs;
      });
    });
  });

  const duration = events.reduce((m,e) => Math.max(m, e.time + e.duration), 0);
  return { events, parts: partList, duration };
}
function pitchToMidi(step, oct, alter){
  const map = { C:0,D:2,E:4,F:5,G:7,A:9,B:11 };
  return (oct + 1) * 12 + (map[step.toUpperCase()] || 0) + (alter || 0);
}

/* ====== UI render for parts & pitches ====== */
function renderPartUI(){
  partsContainer.innerHTML = '';
  // if no part names found, create placeholders
  if(!partNames || partNames.length === 0){
    partNames = ['Part 1','Part 2','Part 3'];
  }
  partNames.forEach((pn, i) => {
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" checked data-index="${i}"> ${pn}`;
    partsContainer.appendChild(label);
    label.querySelector('input').addEventListener('change', () => {
      updateFilters();
    });
  });
}
function renderPitchUI(){
  pitchesContainer.innerHTML = '';
  // unique pitch names already computed
  if(!pitchNames || pitchNames.length === 0){
    // fallback: collect some from parsedEvents or provide common pitches
    const fallback = Array.from(new Set(parsedEvents.map(e=>e.pitchName))).slice(0,12);
    pitchNames = fallback.length ? fallback : ['C4','D4','E4'];
  }
  pitchNames.forEach(p => {
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" checked data-pitch="${p}"> ${p}`;
    pitchesContainer.appendChild(label);
    label.querySelector('input').addEventListener('change', () => {
      updateFilters();
    });
  });
}

/* ====== Filters: apply part visibility and playback filters ====== */
async function updateFilters(){
  // which parts selected
  let selectedParts = Array.from(partsContainer.querySelectorAll('input'))
    .map(i => i.checked ? parseInt(i.getAttribute('data-index')) : null)
    .filter(x => x !== null);

  // which pitches selected (for playback)
  let selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(i => i.checked ? i.getAttribute('data-pitch') : null)
    .filter(Boolean);

  // If user has unchecked everything, restore all by default
  if(selectedParts.length === 0){
    // check all in UI
    Array.from(partsContainer.querySelectorAll('input')).forEach(cb => cb.checked = true);
    selectedParts = Array.from(partsContainer.querySelectorAll('input')).map(i=>parseInt(i.getAttribute('data-index')));
    log('注意: パートが未選択だったため全選択に戻しました。');
  }
  if(selectedPitches.length === 0){
    Array.from(pitchesContainer.querySelectorAll('input')).forEach(cb => cb.checked = true);
    selectedPitches = Array.from(pitchesContainer.querySelectorAll('input')).map(i => i.getAttribute('data-pitch'));
    log('注意: ピッチが未選択だったため全選択に戻しました。');
  }

  // Use osmd.setOptions({drawOnlyParts: [...]}) to show/hide parts
  try{
    osmd.setOptions({ drawOnlyParts: selectedParts.length ? selectedParts : [] });
    await osmd.render();
    log(`OSMD: 再描画（表示パート: ${selectedParts.length ? selectedParts.join(',') : 'all'})`);
  }catch(e){
    console.warn('OSMD re-render failed:', e);
  }

  // Reschedule playback according to current selections (preserve current transport time if playing)
  const currentlyPlaying = (Tone.Transport.state === 'started');
  const currentSec = Tone.Transport.seconds;

  // dispose existing parts
  for(const p of toneParts){ try{ p.dispose(); }catch(_){} }
  toneParts = [];

  scheduleToneParts();

  if(currentlyPlaying){
    Tone.Transport.start(undefined, currentSec);
  } else {
    Tone.Transport.stop();
    updateCursorOnce();
  }
}

/* ====== Schedule Tone.Part per part (stable playback) ====== */
function scheduleToneParts(){
  // clear previous schedules / callbacks
  Tone.Transport.cancel();
  // dispose any existing parts
  for(const p of toneParts){ try{ p.dispose(); }catch(_){ } }
  toneParts = [];

  // which parts and pitches are selected
  let selectedParts = Array.from(partsContainer.querySelectorAll('input'))
    .map(i => i.checked ? parseInt(i.getAttribute('data-index')) : null)
    .filter(x => x !== null);
  let selectedPitches = Array.from(pitchesContainer.querySelectorAll('input'))
    .map(i => i.checked ? i.getAttribute('data-pitch') : null)
    .filter(Boolean);

  // if none selected, default to all (and ensure UI is checked)
  if(selectedParts.length === 0){
    Array.from(partsContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedParts = Array.from(partsContainer.querySelectorAll('input')).map(i=>parseInt(i.getAttribute('data-index')));
  }
  if(selectedPitches.length === 0){
    Array.from(pitchesContainer.querySelectorAll('input')).forEach(cb=>cb.checked = true);
    selectedPitches = Array.from(pitchesContainer.querySelectorAll('input')).map(i=>i.getAttribute('data-pitch'));
  }

  const tempoScale = parseInt(tempoPercent.value) / 100;

  // Build event arrays per selected part
  for(const partIndex of selectedParts){
    const partEvents = parsedEvents
      .filter(e => e.partIndex === partIndex && selectedPitches.includes(e.pitchName))
      .map(e => ({ time: e.time / tempoScale, duration: e.duration / tempoScale, midi: e.midi }));

    if(partEvents.length === 0) {
      // no notes for this part & pitch selection — skip creating a Tone.Part
      log(`パート ${partIndex} に再生イベントがありません（選択フィルタ適用後）`);
      continue;
    }

    // Create Tone.Part for this part
    const p = new Tone.Part((time, val) => {
      synth.triggerAttackRelease(Tone.Frequency(val.midi, 'midi'), val.duration, time);
    }, partEvents);

    p.start(0);
    toneParts.push(p);
  }

  if(toneParts.length === 0){
    log('注意: フィルタ適用後、再生対象がありません（パート/ピッチを確認してください）。');
    // compute totalDuration unchanged (original), update UI
    durationLabel.textContent = formatTime(totalDuration);
    return;
  }

  // schedule cursor updater regularly (Transport.scheduleRepeat)
  // cancel earlier scheduled callbacks first (we did Tone.Transport.cancel() above)
  Tone.Transport.scheduleRepeat(updateCursorOnce, 0.03);

  // compute effective total duration considering tempo
  const effectiveTotal = totalDuration / (parseInt(tempoPercent.value) / 100);
  durationLabel.textContent = formatTime(effectiveTotal);
}

/* ====== Playback control ====== */
async function playMusic(){
  await Tone.start();
  if(toneParts.length === 0){
    scheduleToneParts();
  }
  if(Tone.Transport.state !== 'started'){
    Tone.Transport.start();
  }
  log('再生開始');
  cursorLine.style.display = 'block';
}
function pauseMusic(){
  if(Tone.Transport.state === 'started'){ Tone.Transport.pause(); log('一時停止'); }
}
function stopMusic(){
  if(Tone.Transport.state === 'started' || Tone.Transport.state === 'paused'){
    Tone.Transport.stop();
  }
  for(const p of toneParts){ try{ p.dispose(); }catch(_){}
  }
  toneParts = [];
  Tone.Transport.cancel();
  progressBar.style.width = '0%';
  timeLabel.textContent = '0:00';
  cursorLine.style.display = 'none';
  log('停止');
}

/* ====== Update cursor and auto-scroll (called frequently) ====== */
function updateCursorOnce(){
  const tempoScale = parseInt(tempoPercent.value)/100;
  const effectiveTotal = totalDuration / tempoScale;
  const sec = Tone.Transport.seconds;
  const pct = effectiveTotal > 0 ? Math.min(1, sec / effectiveTotal) : 0;
  progressBar.style.width = (pct * 100) + '%';
  timeLabel.textContent = formatTime(sec);
  const width = osmdCanvas.scrollWidth || osmdCanvas.clientWidth || 1;
  const left = pct * width;
  cursorLine.style.left = left + 'px';
  cursorLine.style.display = 'block';
  const desired = Math.max(0, left - osmdCanvas.clientWidth/2);
  osmdCanvas.scrollLeft = desired;
  if(pct >= 1){
    stopMusic();
  }
}

/* ====== Reschedule from arbitrary time (for tempo changes/resume) ====== */
function rescheduleFrom(sec){
  try{ Tone.Transport.pause(); }catch(_){}
  for(const p of toneParts){ try{ p.dispose(); }catch(_){}
  }
  toneParts = [];
  scheduleToneParts();
  Tone.Transport.start(undefined, sec);
  log('再スケジュール: 再開時刻=' + sec.toFixed(2) + 's');
}

/* ====== Click on score to jump to position ====== */
osmdCanvas.addEventListener('click', (ev) => {
  // Map click x -> logical time in score (scaled by tempo)
  const rect = osmdCanvas.getBoundingClientRect();
  const x = ev.clientX - rect.left + osmdCanvas.scrollLeft;
  const width = osmdCanvas.scrollWidth || osmdCanvas.clientWidth || 1;
  const pct = Math.max(0, Math.min(1, x / width));
  const tempoScale = parseInt(tempoPercent.value)/100;
  const effectiveTotal = totalDuration / tempoScale;
  const targetSec = Math.max(0, Math.min(effectiveTotal, pct * effectiveTotal));

  // restart playback at targetSec
  if(Tone.Transport.state === 'started' || Tone.Transport.state === 'paused'){
    stopMusic();
  }
  scheduleToneParts();
  Tone.Transport.start(undefined, targetSec);
  log(`クリック再生: ${targetSec.toFixed(2)}s（${(pct*100).toFixed(1)}%）`);
  cursorLine.style.display = 'block';
});

/* ====== Utilities ====== */
function formatTime(s){
  if(!isFinite(s) || s <= 0) return '0:00';
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  return `${m}:${sec < 10 ? '0' : ''}${sec}`;
}
</script>
</body>
</html>
